#### 原型(prototype)：
答：一个简单的对象，通俗点说原型是一个对象模版，用于实现对象的属性继承，数据共享，节省内存空间

#### 构造函数(constructor):
答：通过new创建一个对象的函数

#### 实例：
答：通过构造函数和new创建出来的对象。实例通过_proto_指向原型，通过constructor指向构造函数

#### 原型/构造函数/实例关系：
* 实例.__proto__ === 原型
* 原型.constructor === 构造函数
* 构造函数.prototype === 原型
* 实例.constructor === 构造函数

#### 原型链：
答：原型链是由原型对象组成，每个对象都有__proto__属性，指向创建该对象的构造函数原型，__proto__将对象连接起来组成了原型链。用于实现继承和共享数据的有限的对象链。通俗点讲利用原型让一个引用类型继承另一个引用类型的属性和方法
* 属性查找机制：当查找对象属性时，若实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，若还没有找到，则输出undefined
* 属性修改机制：只会修改实例对象本身的属性，若不存在，则进行添加该属性

#### 执行上下文:
答：相当于一个对象，当代码执行的时候，会产生一个对应的执行环境，在这个环境中，所有的变量都会被事先提出来(变量提升)，有的直接赋值，没有的默认值为undefined，代码从上到下依次执行，就叫做执行上下文

###### 属性：
* 变量对象(VO)
* 作用域链(词法作用域)
* this指向

##### 特点：
* 单线程，在主进程运行
* 同步执行，从上往下依次执行
* 全局上下文只能有一个，在浏览器关闭时自动销毁
* 函数的执行上下文没有数目限制
* 函数每被调用一次，就会产生一个新的执行上下文

##### 生命周期:
* 创建阶段：生成变量对象、建立作用域链、确定this指向
* 执行阶段：变量赋值、函数引用、执行其他代码
* 销毁阶段：执行完毕出栈，等待回收被销毁

##### 执行过程：
答：执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完后，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态下的执行上下文环境只有一个

#### 变量对象(VO)：
答：执行上下文的一部分，可以抽象为一种数据作用域，也可以理解为是一个简单的对象，它存储着该执行上下文中所有的变量和函数声明(不包括函数表达式)

#### 活动对象(AO)：
答：当变量对象所处的上下文为active EC(Execution Context,执行上下文) 时，称为活动对象

#### 作用域：
答：作用域为该执行上下文中声明的变量和声明的作用范围。可分为块级作用域和函数作用域

##### 特性：
* 声明提前：一个声明在函数体内都是可见的，函数优先于变量
* 非匿名自执行函数，函数变量是只读状态，无法修改

#### 作用域链：
答：作用域链可以理解为一组对象列表，包含父级和自身的变量对象，因此便能通过作用域链访问到父级里声明的变量或函数

#### 闭包：
答：闭包属于一种特殊的作用域，称为静态作用域。它的定义可以理解为父函数被销毁的情况下，返回的子函数的[[scope]]中仍然保留着父级函数的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包

##### 闭包会产生一个很经典问题：
答：多个子函数的[[scope]]都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有的子函数都会受到影响

##### 问题解决方案：
* 变量通过函数参数的形式传入，避免使用默认的[[scope]]向上查找
* 使用setTimeout包裹，通过第三个参数传入
* 使用块级作用域，让变量成为自己上下文的属性，避免共享

#### script引入方式：
* html静态<script>引入
* js动态插入<script>
* <script defer>：延迟加载，元素解析完后执行
* <script async>：异步加载，但执行时会阻塞元素渲染

#### 对象的拷贝：
* 浅拷贝：以赋值的形式拷贝引用对象，扔指向同一个地址，修改时原对象也会受到影响
    * Object.assign
    * 展开运算符(...)
* 深拷贝：完全拷贝一个新对象，修改时原对象不再受到任何影响
    * JSON.parse(JSON.stringify(obj))：性能最快
        * 具有循环引用的对象时，报错
        * 当值为函数、undefined、symbol时，无法拷贝
    * 递归进行逐一赋值

#### new运算符的执行过程：
* 新生成一个对象
* 链接到原型：obj._proto_ = Con.prototype
* 绑定this： apply
* 返回新对象(若构造函数有自己的return时，返回该值)

#### instanceof原理：
答：能在实例的原型对象链中找到该构造函数的prototype属性所指向的原型对象，就返回true

```javascript
// __proto__: 代表原型对象链
instance.[__proto__...] === instance.constructor.prototype
// return true
```
#### 代码的复用：
答：当发现任何代码开始写第二遍时，就要开始考虑如何复用。

##### 代码复用方式：
* 函数封装
* 继承
* 复制extend
* 混入mixin
* 借用apply/call

#### 继承：












